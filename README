NAME
    IO::CaptureOutput - capture STDOUT and STDERR from Perl code,
    subprocesses or XS

VERSION
    This documentation describes version 1.07_01.

SYNOPSIS
         use IO::CaptureOutput qw(capture capture_exec);
     
     my ($stdout, $stderr);
     
     sub noisy {
             warn "this sub prints to stdout and stderr!";
             print "arguments: @_";
         }
     
     capture sub {noisy(@args)}, \$stdout, \$stderr;
     
     ($stdout, $stderr) = capture_exec( 'perl', '-e', 
             'print "Hello"; print STDERR "World!"');

DESCRIPTION
    This module provides routines for capturing STDOUT and STDERR from perl
    subroutines, forked system calls (e.g. "system()", "fork()") and from XS
    or C modules.

FUNCTIONS
    The following functions will be exported on demand.

  capture()
         capture \&subroutine, \$stdout, \$stderr;

    Captures everything printed to "STDOUT" and "STDERR" for the duration of
    &subroutine. $stdout and $stderr are optional scalars that will contain
    "STDOUT" and "STDERR" respectively.

    Returns the return value(s) of &subroutine. The sub is called in the
    same context as "capture()" was called e.g.:

         @rv = capture sub {wantarray}; # returns true
         $rv = capture sub {wantarray}; # returns defined, but not true
         capture sub {wantarray};       # void, returns undef

    "capture()" is able to capture output from subprocesses and C code,
    which traditional "tie()" methods of output capture are unable to do.

    Note: "capture()" will only capture output that has been written or
    flushed to the filehandle.

    If the two scalar references refer to the same scalar, then "STDERR"
    will be merged to "STDOUT" before capturing and the scalar will hold the
    combined output of both.

         capture \&subroutine, \$combined, \$combined;

    Normally, "capture()" uses anonymous, temporary files for capturing
    output. If desired, specific file names may be provided instead as
    additional options.

         capture \&subroutine, \$stdout, \$stderr, $out_file, $err_file;

    Files provided will be clobbered, overwriting any previous data, but
    will persist after the call to "capture" for inspection or other
    manipulation.

    By default, when no references are provided to hold STDOUT or STDERR,
    output is captured and silently discarded.

         # Capture STDOUT, discard STDERR
         capture \&subroutine, \$stdout;
     
     # Discard STDOUT, capture STDERR
         capture \&subroutine, undef, \$stderr;

    If either STDOUT or STDERR should be passed through to the terminal
    instead of captured, provide a reference to undef -- "\undef" -- instead
    of a capture variable.

         # Capture STDOUT, display STDERR
         capture \&subroutine, \$stdout, \undef;
     
     # Display STDOUT, capture STDERR
         capture \&subroutine, \undef, \$stderr;

  capture_exec()
         ($stdout, $stderr) = capture_exec(@args);

    Captures and returns the output from "system(@args)". In scalar context,
    "capture_exec()" will return what was printed to "STDOUT". In list
    context, it returns what was printed to "STDOUT" and "STDERR"

         $stdout = capture_exec('perl', '-e', 'print "hello world"');
     
     ($stdout, $stderr) = capture_exec('perl', '-e', 'warn "Test"');

    "capture_exec" passes its arguments to "system()" and on MSWin32 will
    protect arguments with shell quotes if necessary. This makes it a handy
    and slightly more portable alternative to backticks, piped "open()" and
    "IPC::Open3".

    You can check the exit status of the "system()" call with the $?
    variable. See perlvar for more information.

  capture_exec_combined()
         $combined = capture_exec_combined(
             'perl', '-e', 'print "hello\n"', 'warn "Test\n"
         );

    This is just like "capture_exec()", except that it merges "STDERR" with
    "STDOUT" before capturing output and returns a single scalar.

    Note: there is no guarantee that text printed to "STDOUT" and "STDERR"
    in the subprocess will be appear in order. The actual order will depend
    on how IO buffering is handled in the subprocess.

  qxx()
    This is an alias for "capture_exec()".

  qxy()
    This is an alias for "capture_exec_combined()".

SEE ALSO
    *   IPC::Open3

    *   IO::Capture

    *   IO::Utils

AUTHORS
    *   Simon Flack <simonflk _AT_ cpan.org> (original author)

    *   David Golden <dagolden _AT_ cpan.org> (co-maintainer since version
        1.04)

COPYRIGHT AND LICENSE
    Portions copyright 2004, 2005 Simon Flack. Portions copyright 2007 David
    Golden. All rights reserved.

    You may distribute under the terms of either the GNU General Public
    License or the Artistic License, as specified in the Perl README file.

